<head>
<title>House <%=  @house %></title>
</head>

<h1><%= @house %> Family Tree</h1>
<svg width="1000" height="1000" ></svg>
<%= tag(:object, id: "tree", data: image_path(@house+"_family_tree.svg"), type: "image/svg+xml", target: "_blank") %>

<style>


text {
	  font: 10px sans-serif;
	    pointer-events: none;
}

.links line {
	  stroke: #999;
	    stroke-opacity: 0.6;
}

</style>
<script>
var house =  '<%=@house%>'
$.ajax({
	   type: "GET",
           contentType: "application/json; charset=utf-8",
	   url: 'display?name='+house,
           dataType: 'json',
           success: function (data) {
		                  draw(data);
				             },
           error: function (result) {
		                  console.log("error");
				             }
       });
 
function draw(data) {
	console.log(data)
	


	
	
	houseColours = {
		"Stark":"#CCCCCC",
		"Tully":"#0000A0",
		"Baratheon":"#FFFF00",
		"Lannister":"#800000",
		"Tyrell":"#008000",
		"Arryn":"#5B91FF",
		"Martell":"#FFA500",
		"Greyjoy":"#FFA500",
		"Targaryen":"#FF0000"

	}
	var svg = d3.select("svg"),
	        width = +svg.attr("width"),
		    height = +svg.attr("height");

	var color = d3.scaleOrdinal(d3.schemeCategory20);

	var nodes = data.people.map(function(p) {
			return {"id": p.id, "name": p.name, "colour" : houseColours[p.house] , "dates": dates(p), "value": 1, "father": (p.father == 0) ? {} : p.father, "mother": (p.mother == 0) ? {} : p.mother}
			})
	var links = []
	data.people.forEach(function(p) {
			var relationships = data.relationships.filter(function(r) {
					return r.person_1 == p.id
					})
			relationships.forEach(function(r) {
				nodes.push({"id": p.id + ' ' + r.person_2, "value": 0})
				links.push({"source": p.id, "target": p.id + ' ' + r.person_2})
				links.push({"source": r.person_2, "target": p.id + ' ' + r.person_2})
			})	
			})
	data.people.forEach(function(p) {
				var parents = data.relationships.filter(function(r) {
					return (r.person_1 == p.father  && r.person_2 == p.mother)|| (r.person_2 == p.father && r.person_1 == p.mother)
					})
				if (parents.length == 1) {
					links.push({"target":p.id, "source": parents[0].person_1 + ' ' + parents[0].person_2})
				}
			})
	
	while (nodes.some(function(n) {return n.generation === undefined || isNaN(n.generation)})) {
		nodes.forEach(function(n) {
			parentGenerations = nodes.filter(function(p) {return n.mother == p.id || n.father == p.id}).map(function(p) {return p.generation})
			if (parentGenerations.length == 0) {
				n.generation = 0
			} else {
		
			if (!parentGenerations.some(function(g) {return g === undefined || isNaN(g)})) {
			n.generation = 1+Math.max.apply(null, parentGenerations)
			}
			}
			})
	}
	nodes.forEach(function(n) {
		if (n.generation == 0) {	
			spouseIds = data.relationships.filter(function(r) {return r.person_1 == n.id || r.person_2 == n.id}).map(function(r) {if (r.person_1 == n.id) {return r.person_2} else {return r.person_1}})
			spouseGenerations = nodes.filter(function(p) {return spouseIds.includes(p.id)}).map(function(p) {return p.generation})
			childrenGenerations = nodes.filter(function(p) {return p.father == n.id || p.mother == n.id}).map(function(p) {return p.generation})
			if (spouseGenerations.length == 0) {
				if (childrenGenerations.length != 0) {
					n.generation = Math.min.apply(null, childrenGenerations)-1
				}
			} else {
				spouseMax = Math.max.apply(null, spouseGenerations)
				n.generation = spouseMax
				if (childrenGenerations.length != 0) {
					n.generation = Math.min(n.generation, Math.min.apply(null, childrenGenerations)-1)
				} 

			}
		}
		})
	nodes.forEach(function(n) {
			if (n.value == 0) {
				ids = n.id.split(' ')
				generations = nodes.filter(function(p) {return p.id == ids[0] || p.id == ids[1]}).map(function(p) {return p.generation})
				n.generation = (generations[0] + generations[1])/2 + 0.5
			}
	})
	console.log(nodes.map(function(n){return n.name + ": " + n.generation}))	
	var rectWidth = 110;
	var rectHeight = 35;
	
	
var simulation = d3.forceSimulation()
	    .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(rectHeight))
	    .force("charge", d3.forceManyBody())
	    .force("collide", d3.forceCollide(Math.max(rectWidth, rectHeight)*0.5).strength(0.35))
	    .force("yAxis", d3.forceY(function(d) {return 5.5*d.generation*rectHeight}).strength(1))
	    .force("center", d3.forceCenter(width / 2, height / 2));
  var link = svg.append("g")
        .attr("class", "links")
	    .selectAll("path")
	        .data(links)
		    .enter().append("path")
		          .attr("stroke-width", 1)
			  .attr("fill", "none")
			  .attr("stroke", "black")
			  .attr("id", function(l) {return l.source + ',' + l.target})
	   var node = svg.append("g")
	   .attr("class", "nodes")
	   .selectAll("node")
		         .data(nodes)
			 .enter().
			 append("g")
			    
	
	var rect = node.append("rect")
	.attr("width", function(d){return d.value*rectWidth})
	.attr("height", function(d){return d.value*rectHeight})
	.attr("stroke", "black")
			     .attr("fill", function(d) {return (d.colour === undefined) ? "white" : d.colour})
			     .attr("stroke-width", 2)
			     .attr("id", function(d){return d.id})
			     .on("mouseover", highlightNeighbours)
			     .on("mouseout", reset)
	var label =  node.append("text")
			.attr("text-anchor", "middle")
			.text(function(d) { return d.name })
	var dates = node.append("text")
			.attr("text-anchor", "middle")
			.text(function(d) { return d.dates})
function highlightNeighbours(d) {
	var neighbours = immediateFamily(d)
	svg.selectAll('rect').filter(function(n) {return neighbours.includes(n.id)}).style('stroke-width', 4)
	var linksWithNodes = svg.selectAll('path').filter(function(p) {return neighbours.includes(p.source.id) || neighbours.includes(p.target.id)})	
	var linksConnectingNodes = linksWithNodes.filter(function(p) {
			if (neighbours.includes(p.source.id)) {
			return linksWithNodes.filter(function(l) {return l.source.id == p.target.id || l.target.id == p.target.id   })._groups[0].length > 1
			} else {

			return linksWithNodes.filter(function(l) {return l.source.id == p.source.id || l.target.id == p.source.id   })._groups[0].length > 1
			}
	})
	linksConnectingNodes.style('stroke-width', 2)
}
function reset(d) {
	var neighbours = immediateFamily(d)
	svg.selectAll('rect').filter(function(n) {return neighbours.includes(n.id)}).style('stroke-width', 2)
	var linksWithNodes = svg.selectAll('path').filter(function(p) {return neighbours.includes(p.source.id) || neighbours.includes(p.target.id)})
	var linksConnectingNodes = linksWithNodes.filter(function(p) {
			if (neighbours.includes(p.source.id)) {
			return linksWithNodes.filter(function(l) {return l.source.id == p.target.id   })._groups.length > 0
			} else {
			return linksWithNodes.filter(function(l) {return p.source.id == l.target.id   })._groups.length > 0
			}
	})

	linksConnectingNodes.style('stroke-width', 1)

}

function immediateFamily(d) {
	var neighbours = [d.id]
	neighbours = neighbours.concat(nodes.filter(function(n) {return d.father == n.id || d.mother == n.id}).map(function(n) {return n.id}))
	neighbours = neighbours.concat(nodes.filter(function(n) {return n.father == d.id || n.mother == d.id}).map(function(n) {return n.id}))
	neighbours = neighbours.concat(data.relationships.filter(function(r) {return r.person_1 == d.id || r.person_2 == d.id}).map(function(r) {if (r.person_1 == d.id) {return r.person_2} else {return r.person_1} }))
	neighbours= neighbours.concat(nodes.filter(function(n) {return n.father == d.father || n.mother == d.mother}).map(function(n) {return n.id}))
	return neighbours
}
function elbow(d, i) {
       			if (!isNaN(d.source.id)) {	
			return "M" + d.source.x + "," + d.source.y
				+ "V" + d.target.y + "H" + d.target.x;
			} else {
				return "M" + d.target.x + "," + d.target.y
					+ "V" +  (d.target.y + (d.source.y-d.target.y)/2) + "H" + d.source.x + "V" + d.source.y;
			}
}
function dates(p) {
	result = '';
	if (p.year_of_birth > 0) {
		result += p.year_of_birth;
	} else if (p.year_of_birth == -1) {
		result += '???';
	}
	result += '-';
	if (p.year_of_death > 0) {
		result += p.year_of_death
	} else if (p.year_of_death == -1) {
		result += '???'
	}
	return result
}
	simulation
	 .nodes(nodes)
	 .on("tick", ticked) 
simulation.force("link")
.links(links)

	   function ticked() {
		    link
			         .attr("d", elbow)
		          rect
				          .attr("x", function(d) { return d.x-rectWidth/2; })
					          .attr("y", function(d) { return d.y-rectHeight/2; });
				label.attr("x", function(d) { return d.x; })
					.attr("y", function(d) { return d.y;})
				dates.attr("x", function(d) { return d.x; })
					.attr("y", function(d) { return d.y+12;})
			   }
}
var tree = document.getElementById('tree')
tree.style.width = (window.innerWidth) + "px"
tree.style.height = (window.innerHeight * 0.78) + "px"

var beforePan

beforePan = function(oldPan, newPan){
    var stopHorizontal = false, 
    stopVertical = false, 
    gutterWidth = window.innerWidth*0.1, 
    gutterHeight = window.innerHeight*0.1, 

    sizes = this.getSizes(), 
    leftLimit = -((sizes.viewBox.x + sizes.viewBox.width) * sizes.realZoom) + gutterWidth,
    rightLimit = sizes.width - gutterWidth - (sizes.viewBox.x * sizes.realZoom), 
    topLimit = -((sizes.viewBox.y + sizes.viewBox.height) * sizes.realZoom) + gutterHeight,
    bottomLimit = sizes.height - gutterHeight - (sizes.viewBox.y * sizes.realZoom)

    customPan = {}
    customPan.x = Math.max(leftLimit, Math.min(rightLimit, newPan.x))
    customPan.y = Math.max(topLimit, Math.min(bottomLimit, newPan.y))

    return customPan
}


document.getElementById('tree').addEventListener('load', function(){
  svgPanZoom(document.getElementById('tree'), {
          zoomEnabled: true,
          controlIconsEnabled: false,
          maxZoom: 5,
          minZoom: 1,
          beforePan: beforePan
        }); 
})
</script>


